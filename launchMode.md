1. Android手机里的最近任务列表显示的是一个个Task，当我们点击App图标的时候，App的默认activity会被启动，并且这个activity会被放进系统刚创建的一个Task里，每个Task都有自己的回退栈，这个回退栈按顺序记录了用户打开的每个activity，这样当用户按返回键的时候就可以按照倒序来依次关闭这些activity，当回退栈里最后一个activity被关闭，这个Task的声明也就结束了，但它(task)并不会从最近任务列表里消失，系统依然会保留这个Task的一个残影给用户，这样做的目的是让用户可以方便的切回去，只是这种切回去其实是对App的重新启动，因为原先的那个Task已经不存在了。**所以在最近任务里看见的Task未必是活着的**
2. Activity是一个可以跨进程，跨应用的组件，当你在A App里打开B App的activity的时候，这个activity会直接被放进A的Task里，而对于B的task是没有任何影响的，当你在不同的task里打开相同activity的时候，这个activity会被创建出不同的实例，分别放在每一个task里(这是Android的默认规则)
3. SingleTask,这种启动模式可以让activity被别的App启动的时候，不会进入启动它的Task里，而是会在属于它自己的Task里创建，放在自己的栈顶，然后把整个task延期拿过来，压在启动它的Task的上面，，这种启动模式可以保证，不管是从哪个App启动，被标记为singleTask的activity总会被放在自己的Task里。切记，task的叠加只始于用前台的task，前台叠加的多个Task在进入后台的第一时间就会被拆开。前台Task进入后台最常见的场景有两种：①按Home键回到桌面②按最近任务键查看最近任务，需要注意的是前台Task是在显示最近任务的时候就已经进入了后台-----这种逻辑还有一种实现方式，就是allowTaskReparenting属性(true)在A App里启动了B App里标记这个属性为true的activity，那么在启动B App的时候原先放在A App里的activity会被挪过来，放进B的task里，在回退栈的顶端被显示出来（但是在Android9，10上无效，在Android11上是好的，谨慎使用），总之SingleTask除了保证activity在固定的Task里创建，还可以保证在此Task里的唯一性，即：如果启动的时候这个Task的栈里已经有了这个activity，就不会再创建新对象，同时由于因为activity没有被重新创建，系统也就不会调用它的onCreate方法，而是调用它的onNewInent()方法
4. SingleInstance,这种启动模式和singleTask差不多，只不过这种启动模式更严格，它要求这个activity所在的Task里只有它这么一个activity，
5. Singletask和SinnleInstance在实际的操作中的区别，①在被启动之后，用户按返回键的时，sinngleTask会在自己的App里进行回退，而singleInstance会直接回到原先的App，②用户稍后从桌面点开Activity所在的App的图标的时候，singtask会看到这个activity依然在栈顶，而singleInstance会看到这个activity已经不见了(并没有被杀死)---在最近任务里看不见的Task也未必就“死”了，为什么呢?为什么在最近任务里看不见singleInstance的task呢，**因为它们的taskAffinity冲突了。在Android里，一个App默认最多只有一个Task可以显示在最近任务列表里**，用来判断这个唯一性的并不是App，而是taskAffinity
6. TaskAffinity，相似，有关联。在Android里每一个activity都有一个taskAffinity，它就相当于试试对每个activity进行的一个预先的分组，它的值默认取自所在的Application的taskAffinity，而Application的taskAffinity默认取自App的包名，**另外每个task也有它的taskAffinity，它的值取自栈底的activity的taskaffinity**，默认情况下，一个App里面，所有task的taskaffnity都是一样的，就是app的包名。当我们启动一个新的Task的时候，比如开机后初次点开一个App，这个Task就会得到一个taskAffinity，它的值就是它启动的第一个activity的的taskaffinity，当我们继续从已经打开的activity里再次打开新弄的activity的时候，taskaffinit就被忽略了，新的activity会直接入栈，不管它来自哪，但是如果新的activity被配置了singTask，Android就会检查新的activity的taskaffinity和当前task的taskaffinity是不是相同，如果相同就继续入栈，而如果不同新的activity就会进入和它自己的taskaffnity相同的task或者创建一个新的task。。当我们查看最近任务的时候不同的task会并列展示出来，但有一个前提，他们的taskaffinity需要不一样。在android里，同一个taskaffinity的可以被创建出多个task，但他们最多只有一个出现在最近任务列表里(singleinstance)
7. SingleTop和默认的模式基本一样，唯一区别时如果栈顶的activity恰好就是要启动的activity，那就不新建了，而调用onNewIntent()